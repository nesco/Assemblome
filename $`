"""This module contains the parser that translate every non nucleotide sequences into sequences of nucleotides.
Once used, all the information remaining should be directly expressed in terms of nucleotides. It means there should not be any longer references to amino-acids, complements, and databases"""

### Imports
import re
from utils import *
from utils_genomics import specify, translate

### Databases
DB_UNIPROT = Uniprot()

### Patterns

REGEX_FUNCTIONAL_EXPRESSION = r'([A-Za-z0-9+\/=]+@)?([ARNDCQEGHILKMFPSTWYV]+)\.aa'

# PDB and Uniprot
# Either 'PCHS.pdb'
# Or 'from PDB import PCHS as random_protein' (equivalent to a tag PCHS.pdb as random_protein)
REGEX_PDB_CHAIN = r'(?P<id_pdb>[A-Z0-9]{4})(?P<chain>:\d)?\.pdb'
REGEX_UNIPROT_CHAIN = r'(?P<id_uniprot>[A-Z0-9]{6,11})\.up'

## Functions

# Assembly

def replace_pdb_by_aa_chain(match):
    pdb_id = match.group(1)
    digit = match.group(2)

    if digit:  # if the optional digit part exists, remove the colon
        digit = int(digit[1])
    else:
        digit = 0

    return pdb_to_fasta_chains(pdb_id)[digit] + '.aa'

def replace_uniprot_by_aa_chain(match):
    uniprot_id = match.group(1)
    return DB_UNIPROT.get_sequence(uniprot_id) + '.aa'

def replace_ids(s):
    output = re.sub(REGEX_PDB_CHAIN, replace_pdb_by_aa_chain, s)
    output = re.sub(REGEX_UNIPROT_CHAIN, replace_uniprot_by_aa_chain, output)
    return output

def parse_ids(content: list[str]) -> list[str]:
    return [replace_ids(line) for line in content]

def replace_functional_expression(match_obj):
    """Replace functional expressions complement@amin-acid_chain and by Rna chains"""
    complement = match_obj.group(1)
    aa_chain = match_obj.group(2)

    if complement:
        #removing the "@" which is also captured by the capture group
        complement = complement[:-1]
    else:
        complement = ""

    rna_chain = specify(aa_chain, base64_to_list(complement)) + '.rna'
    return rna_chain


def process_functional_expressions(s):
    return re.sub(REGEX_FUNCTIONAL_EXPRESSION, replace_functional_expression, s)

def parse_functional_expressions(content):
    return [process_functional_expressions(line) for line in content]

### Parser

class ParserConverter():
    
    def __init__(self):
        self.content = None

    def parse(self, content):
        # make content a multiline string
        self.content = '\n'.join(content)
        self.content = replace_ids(self.content)
        self.content = process_functional_expressions(self.content)

        # Make it a list of strings agains
        self.content = self.content.split('\n')
        return self.content

